\section{System Implementation}

The implementation of the above design is split up into three distinct sections, namely the Presentation, Business and Data Layers.

\subsection{Presentation Layer}

The general theme of the interface is modern and based on industry standards such as Google Material Design. This is meant to let the user feel comfortable and experience no learning curve since it mimics the appearance of common, standout websites with a ‘card’ focus heavily in action, as reiterated by Google.
The login screen has two input fields for the user’s credentials (email and password) once entered and the login button is clicked, the system then verifies the credentials by issuing these encrypted details from the client side to the server side. The server side then checks the credentials against records in the database for each possible entity (student, lecturer, coordinator and administrator) and returns a status (true or false) which indicates the validity of the details. If valid the interface will proceed to the relevant view based on the type of user logging in, otherwise they’ll be notified of the invalid details.

The generic screen displays two tabs (personalised and full) allowing the respective view of the exam timetable. When personalised is clicked, the client requests a list of the exams related to the student or lecturer. This is done by sending the user’s institution identity number to the server which then retrieves the list of exams from the relational database and returns it in json format. A table is then populated with these exams and their details for the user’s convenience and viewing pleasure. When the user clicks on an exam listing, the exam venue of a scheduled exam is extracted from the object and the location is displayed on a map for the user’s navigation purposes by setting the src attribute of the iframe. The full timetable tab deploys a process of simply requesting the full exam timetable to be sent that is currently stored in the database.

The coordinator screen is the same as above with the extension of a course tab which allows the coordinator to enter course details and exam preferences for the course. When the tab is clicked, a card with the required inputs components are displayed. Once the coordinator enters these details and clicks the button, input validation occurs and if valid, the details are sent to the server to be stored in the database. These are considered by the algorithm when constructing an exam timetable. If invalid, the coordinator is notified of this.

The admin screen has a generate tab along with the full timetable tab. This provides the admin with a button to schedule the system to generate an exam timetable based on all the courses and preferences and start and end dates of the examination period. This occurs on the back-end where the algorithm runs and then stores the timetable in the database.

\subsection{Business Layer}
\subsection{Data Layer}

\subsection{Dependencies}

Reinventing the wheel is not good practice and as a result, the use of external libraries plays a vital part in enabling efficiency during our design and implementation of the system. Frameworks and API’s also allow us to implement certain functionality that connects to external services.
On the front-end, libraries such as jQuery, material design lite, material icons and material selectfield all help with the UX and overall appearance of the UI. Material design lite (MDL) and material selectfield are used for the html components and particularly the css styling (through classes) and animation of these components applied through the javascript made available by these libraries. Material icons is used for the inclusion of Google designed icons in our UI such as login, logout and search. jQuery is used for ease of manipulation of DOM elements in javascript. All of these libraries are widely used in industry for modern front-end development. Google maps is also a front-end dependency as it displays an exam venue’s location.
On the back-end, a combination of libraries, packages and API’s are used for implementation. Python sqlite3 is used to read data (concerning entities within the academic institution) and write data (concerning course preferences and the generated exam timetable) to the database. The lightweight nature of this DBMS made it a perfect fit for the system. Python networkx performs the graph-colouring algorithm on our graph of courses in order to generate the exam timetable. Google Calendar API allows us to add exam events on the Google account for each related entity.


\subsection{Pair I - Front End}

The tools used to perform the tasks in section 3.5 are Axure for the wireframe and html, css, js for the interface design.

\subsection{Pair II - Back End}

The tools used to perform the tasks in section 3.5 are Microsoft Visio for the class diagram and entity relationship diagram.

\subsection{Testing}

Testing is a critical part of the development of any system as it ensures the functional and non-functional requirements of the project are met and that the system functions as intended without any serious issues or bugs. Both black box and white box testing are employed in this system as detailed below.

\subsubsection{Server}

Verification was done to ensure the various back end components such as the database connectivity, data retrieval, Google calendar events and timetable generation work correctly.

Unit tests were conducted to ensure that, given certain parameter values, the algorithm produces the correct results. These algorithm was first traced by hand and then the unit tests were used to assert whether the hand calculations and the output of the functions do match.

The output of the Google calendar event creation was also monitored by observing whether an event was actually created given a valid Google account.

Both of the above tests successfully completed and verified that the server-side works correctly.

\subsubsection{Interface}

Unit tests are used to test each of the interface views i.e. generic (used for students and lecturers since they share mutual features), coordinator and administrator. This is done by entering pre-defined login credentials for each type of user on the login screen and observing the resulting interface transition. This ensures the relevant interface view and related components are created based on the type of user so that the user is given the system features that they require.

The interface view is then tested by a user. The user attempts to use the interface to navigate between the various screens. The user clicks on various places on the screens to ensure that no unintended behaviour occurs and then clicks on an available button to test that this is the only place where a change due to a mouse click occurs.

The above tests are completed successfully and determine that the interface works correctly according to the design.
